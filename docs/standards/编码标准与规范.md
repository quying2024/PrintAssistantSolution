# PrintAssistant 编码标准与规范

## 📋 基于项目规划书的编码标准

本编码标准基于 **《托盘打印助手PrintAssistant项目规划01.md》** 制定，确保代码质量与架构设计的一致性。

## 🎯 核心原则

### 1. 架构一致性原则
- 所有代码实现必须严格遵循项目规划书中的架构设计
- 设计模式应用必须与规划书保持一致
- 技术栈选择必须符合规划书要求

### 2. 可测试性原则
- 所有外部依赖必须通过接口抽象化
- 使用依赖注入而非静态依赖
- 每个类和方法都必须可进行单元测试

### 3. 文档完整性原则
- 每个模块/类都要有注释说明输入输出类型及要求
- 使用XML文档注释
- 保持UTF-8 BOM编码，防止中文乱码

### 4. 文件编码一致性原则
- 所有文件必须使用UTF-8 BOM编码
- 文件I/O操作必须显式指定UTF-8编码
- 避免依赖系统默认编码，确保跨平台一致性

## 🏗️ 架构实现标准

### 1. 依赖注入标准

#### 构造函数注入
```csharp
// ✅ 正确：使用构造函数注入
public class FileMonitorService : IFileMonitor
{
    private readonly IFileSystem _fileSystem;
    private readonly ILogger<FileMonitorService> _logger;
    
    public FileMonitorService(IFileSystem fileSystem, ILogger<FileMonitorService> logger)
    {
        _fileSystem = fileSystem ?? throw new ArgumentNullException(nameof(fileSystem));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }
}

// ❌ 错误：使用静态依赖
public class FileMonitorService : IFileMonitor
{
    public void StartMonitoring(string path)
    {
        var watcher = new FileSystemWatcher(path); // 直接使用静态类
    }
}
```

#### 服务生命周期选择
```csharp
// 单例服务：持有状态或代表共享资源
services.AddSingleton<IPrintQueue, PrintQueueService>();
services.AddSingleton<IFileMonitor, FileMonitorService>();

// 瞬态服务：无状态、轻量级
services.AddTransient<IFileConverter, WordToPdfConverter>();
services.AddTransient<SettingsForm>();
```

### 2. 配置管理标准

#### Options模式实现
```csharp
// ✅ 正确：使用强类型配置
public class MonitorSettings
{
    public string Path { get; set; } = string.Empty;
    public int DebounceIntervalMilliseconds { get; set; } = 2500;
}

public class FileMonitorService : IFileMonitor
{
    private readonly MonitorSettings _settings;
    
    public FileMonitorService(IOptions<MonitorSettings> options)
    {
        _settings = options.Value;
    }
}

// ❌ 错误：直接使用IConfiguration
public class FileMonitorService : IFileMonitor
{
    private readonly IConfiguration _configuration;
    
    public FileMonitorService(IConfiguration configuration)
    {
        _configuration = configuration;
    }
    
    public void StartMonitoring()
    {
        var path = _configuration["ApplicationSettings:Monitoring:Path"]; // 字符串键
    }
}
```

### 3. 日志记录标准

#### 结构化日志
```csharp
// ✅ 正确：使用结构化日志
_logger.LogInformation("开始监控文件夹 {Path}，防抖间隔 {Interval}ms", 
    _settings.Path, _settings.DebounceIntervalMilliseconds);

_logger.LogWarning("文件转换失败 {FilePath}，错误：{Error}", 
    filePath, ex.Message);

// ❌ 错误：使用字符串拼接
_logger.LogInformation("开始监控文件夹 " + _settings.Path);
```

### 4. 异步编程标准

#### 异步方法实现
```csharp
// ✅ 正确：使用async/await
public async Task<Stream> ConvertToPdfAsync(string sourceFilePath)
{
    using var fileStream = _fileSystem.File.OpenRead(sourceFilePath);
    using var wordDocument = new WordDocument(fileStream, FormatType.Automatic);
    using var renderer = new DocIORenderer();
    
    var pdfDocument = renderer.ConvertToPDF(wordDocument);
    var pdfStream = new MemoryStream();
    
    await Task.Run(() => pdfDocument.Save(pdfStream));
    pdfStream.Position = 0;
    
    return pdfStream;
}

// ❌ 错误：阻塞调用
public Stream ConvertToPdf(string sourceFilePath)
{
    var fileStream = _fileSystem.File.OpenRead(sourceFilePath);
    // 同步阻塞操作
    return ConvertToPdfSync(fileStream);
}
```

## 📝 代码注释标准

### 1. XML文档注释

#### 类级别注释
```csharp
/// <summary>
/// 文件监控服务，负责监控指定文件夹的文件变化并生成打印作业
/// </summary>
/// <remarks>
/// 实现防抖机制，将连续的文件添加操作聚合为单个打印作业。
/// 使用FileSystemWatcher监控文件系统事件，并通过事件防抖避免任务碎片化。
/// </remarks>
public class FileMonitorService : IFileMonitor
{
    // 实现...
}
```

#### 方法级别注释
```csharp
/// <summary>
/// 开始监控指定路径的文件夹
/// </summary>
/// <param name="path">要监控的文件夹路径</param>
/// <exception cref="ArgumentException">当路径为空或不存在时抛出</exception>
/// <exception cref="UnauthorizedAccessException">当没有访问权限时抛出</exception>
/// <returns>表示异步操作的任务</returns>
public async Task StartMonitoringAsync(string path)
{
    // 实现...
}
```

#### 属性注释
```csharp
/// <summary>
/// 获取或设置作业的唯一标识符
/// </summary>
/// <value>GUID格式的作业ID</value>
public Guid JobId { get; set; }

/// <summary>
/// 获取作业的当前状态
/// </summary>
/// <value>作业状态枚举值</value>
public JobStatus Status { get; set; }
```

### 2. 内联注释标准

```csharp
public async Task ProcessJobAsync(PrintJob job, CancellationToken cancellationToken)
{
    try
    {
        // 更新作业状态为处理中
        job.Status = JobStatus.Processing;
        await _trayIconService.UpdateStatusAsync(job);
        
        // 验证源文件是否仍然存在
        var existingFiles = new List<string>();
        foreach (var filePath in job.SourceFilePaths)
        {
            if (_fileSystem.File.Exists(filePath))
            {
                existingFiles.Add(filePath);
            }
            else
            {
                _logger.LogWarning("源文件不存在，跳过处理：{FilePath}", filePath);
            }
        }
        
        // 如果所有文件都不存在，标记作业为失败
        if (existingFiles.Count == 0)
        {
            job.Status = JobStatus.Failed;
            job.ErrorMessage = "所有源文件都不存在";
            return;
        }
        
        // 转换文件为PDF
        var pdfStreams = new List<Stream>();
        foreach (var filePath in existingFiles)
        {
            var converter = _converterFactory.GetConverter(filePath);
            if (converter != null)
            {
                var pdfStream = await converter.ConvertToPdfAsync(filePath);
                pdfStreams.Add(pdfStream);
            }
            else
            {
                // 不支持的文件类型，移动到指定文件夹
                await _fileArchiver.MoveUnsupportedFileAsync(filePath);
            }
        }
        
        // 合并PDF并执行打印
        if (pdfStreams.Count > 0)
        {
            var mergedPdf = await _pdfMerger.MergeAsync(pdfStreams);
            await _printService.PrintPdfAsync(mergedPdf, job.SelectedPrinter, job.Copies);
            
            // 归档源文件
            await _fileArchiver.ArchiveFilesAsync(existingFiles, job.CreationTime);
            
            job.Status = JobStatus.Completed;
        }
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "处理作业失败 {JobId}", job.JobId);
        job.Status = JobStatus.Failed;
        job.ErrorMessage = ex.Message;
    }
    finally
    {
        // 更新托盘图标状态
        await _trayIconService.UpdateStatusAsync(job);
    }
}
```

## 🧪 测试标准

### 1. 单元测试结构

```csharp
/// <summary>
/// FileMonitorService的单元测试
/// </summary>
public class FileMonitorServiceTests
{
    private readonly Mock<IFileSystem> _mockFileSystem;
    private readonly Mock<IPrintQueue> _mockPrintQueue;
    private readonly Mock<ILogger<FileMonitorService>> _mockLogger;
    private readonly FileMonitorService _service;
    
    public FileMonitorServiceTests()
    {
        _mockFileSystem = new Mock<IFileSystem>();
        _mockPrintQueue = new Mock<IPrintQueue>();
        _mockLogger = new Mock<ILogger<FileMonitorService>>();
        
        _service = new FileMonitorService(
            _mockFileSystem.Object,
            _mockPrintQueue.Object,
            _mockLogger.Object);
    }
    
    [Fact]
    public async Task StartMonitoring_WhenFilesAdded_ShouldAggregateIntoJob()
    {
        // Arrange
        var testPath = @"C:\test";
        var mockFileSystem = new MockFileSystem();
        
        // Act
        await _service.StartMonitoringAsync(testPath);
        
        // 模拟文件添加
        mockFileSystem.AddFile(@"C:\test\file1.txt", "content1");
        mockFileSystem.AddFile(@"C:\test\file2.txt", "content2");
        
        // 等待防抖间隔
        await Task.Delay(3000);
        
        // Assert
        _mockPrintQueue.Verify(
            x => x.EnqueueJobAsync(It.Is<PrintJob>(job => 
                job.SourceFilePaths.Count == 2)), 
            Times.Once);
    }
}
```

### 2. 测试命名规范

```csharp
// 格式：MethodName_Scenario_ExpectedResult
[Fact]
public async Task ConvertToPdfAsync_WhenValidWordFile_ShouldReturnPdfStream()
{
    // 测试实现...
}

[Fact]
public async Task ConvertToPdfAsync_WhenFileNotFound_ShouldThrowFileNotFoundException()
{
    // 测试实现...
}

[Fact]
public async Task ConvertToPdfAsync_WhenCorruptedFile_ShouldThrowInvalidOperationException()
{
    // 测试实现...
}
```

## 🔧 错误处理标准

### 1. 异常处理模式

```csharp
// ✅ 正确：具体的异常处理
public async Task<Stream> ConvertToPdfAsync(string sourceFilePath)
{
    try
    {
        if (!_fileSystem.File.Exists(sourceFilePath))
        {
            throw new FileNotFoundException($"源文件不存在：{sourceFilePath}");
        }
        
        // 转换逻辑...
    }
    catch (SyncfusionException ex)
    {
        _logger.LogError(ex, "Syncfusion转换失败：{FilePath}", sourceFilePath);
        throw new DocumentConversionException($"文档转换失败：{ex.Message}", ex);
    }
    catch (UnauthorizedAccessException ex)
    {
        _logger.LogError(ex, "文件访问权限不足：{FilePath}", sourceFilePath);
        throw;
    }
}

// ❌ 错误：捕获所有异常
public async Task<Stream> ConvertToPdfAsync(string sourceFilePath)
{
    try
    {
        // 转换逻辑...
    }
    catch (Exception ex) // 过于宽泛
    {
        _logger.LogError(ex, "转换失败");
        throw;
    }
}
```

### 2. 自定义异常

```csharp
/// <summary>
/// 文档转换异常
/// </summary>
public class DocumentConversionException : Exception
{
    public DocumentConversionException(string message) : base(message)
    {
    }
    
    public DocumentConversionException(string message, Exception innerException) 
        : base(message, innerException)
    {
    }
}

/// <summary>
/// 打印异常
/// </summary>
public class PrintingException : Exception
{
    public string PrinterName { get; }
    
    public PrintingException(string message, string printerName) : base(message)
    {
        PrinterName = printerName;
    }
    
    public PrintingException(string message, string printerName, Exception innerException) 
        : base(message, innerException)
    {
        PrinterName = printerName;
    }
}
```

## 📊 性能标准

### 1. 文件I/O编码标准

#### 文件读写编码规则
在进行文件 I/O 操作时，必须显式指定 UTF-8 编码，避免依赖系统默认编码。

```csharp
// ✅ 正确：显式指定UTF-8编码
using var reader = new StreamReader(filePath, Encoding.UTF8);
using var writer = new StreamWriter(filePath, false, Encoding.UTF8);

// 使用File类的静态方法
var content = await File.ReadAllTextAsync(filePath, Encoding.UTF8);
await File.WriteAllTextAsync(filePath, content, Encoding.UTF8);

// 读取配置文件
var configContent = await File.ReadAllTextAsync("appsettings.json", Encoding.UTF8);

// 写入日志文件
await File.AppendAllTextAsync(logFilePath, logMessage, Encoding.UTF8);

// ❌ 错误：依赖系统默认编码
using var reader = new StreamReader(filePath); // 可能使用系统默认编码
using var writer = new StreamWriter(filePath); // 可能使用系统默认编码
var content = await File.ReadAllTextAsync(filePath); // 使用系统默认编码
```

#### 编码规则的重要性
- **跨平台一致性**：确保在不同操作系统上文件编码一致
- **中文支持**：避免中文内容出现乱码
- **项目统一性**：与项目UTF-8 BOM编码要求保持一致
- **可维护性**：明确的编码指定便于代码维护

### 2. 内存管理

```csharp
// ✅ 正确：使用using语句管理资源
public async Task<Stream> ConvertToPdfAsync(string sourceFilePath)
{
    using var fileStream = _fileSystem.File.OpenRead(sourceFilePath);
    using var wordDocument = new WordDocument(fileStream, FormatType.Automatic);
    using var renderer = new DocIORenderer();
    
    var pdfDocument = renderer.ConvertToPDF(wordDocument);
    var pdfStream = new MemoryStream();
    
    pdfDocument.Save(pdfStream);
    pdfStream.Position = 0;
    
    return pdfStream;
}

// ❌ 错误：未正确释放资源
public async Task<Stream> ConvertToPdfAsync(string sourceFilePath)
{
    var fileStream = _fileSystem.File.OpenRead(sourceFilePath);
    var wordDocument = new WordDocument(fileStream, FormatType.Automatic);
    var renderer = new DocIORenderer();
    
    // 资源未释放，可能导致内存泄漏
    var pdfDocument = renderer.ConvertToPDF(wordDocument);
    var pdfStream = new MemoryStream();
    
    pdfDocument.Save(pdfStream);
    return pdfStream;
}
```

### 2. 异步操作

```csharp
// ✅ 正确：避免阻塞调用
public async Task ProcessJobAsync(PrintJob job, CancellationToken cancellationToken)
{
    // 使用异步方法
    var pdfStream = await _converter.ConvertToPdfAsync(job.SourceFilePath);
    
    // 使用Task.Run包装同步操作
    await Task.Run(() => _printService.Print(pdfStream), cancellationToken);
}

// ❌ 错误：阻塞异步方法
public async Task ProcessJobAsync(PrintJob job, CancellationToken cancellationToken)
{
    // 阻塞调用
    var pdfStream = _converter.ConvertToPdf(job.SourceFilePath);
    
    // 同步阻塞
    _printService.Print(pdfStream);
}
```

## ✅ 代码审查检查点

### 1. 架构一致性检查
- [ ] 是否遵循了规划书中的设计模式？
- [ ] 是否使用了正确的依赖注入方式？
- [ ] 是否实现了规划书中定义的接口？

### 2. 可测试性检查
- [ ] 所有外部依赖是否都已抽象化？
- [ ] 是否避免了静态依赖？
- [ ] 是否可以通过依赖注入进行测试？

### 3. 代码质量检查
- [ ] 是否有完整的XML文档注释？
- [ ] 是否遵循了命名规范？
- [ ] 是否正确处理了异常？
- [ ] 是否正确管理了资源？

### 4. 性能检查
- [ ] 是否使用了异步操作？
- [ ] 是否正确释放了资源？
- [ ] 是否避免了内存泄漏？

---

**重要提醒**：这些编码标准是确保项目质量的基础，请在所有开发工作中严格执行。

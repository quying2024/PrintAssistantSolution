# PrintAssistant 项目开发规则

## 📋 项目规则概述

本文档定义了PrintAssistant项目的开发规则、约束和最佳实践。所有参与项目开发的成员都必须严格遵守这些规则。

## 🎯 核心规则原则

### 1. 规划书权威性原则
- **《托盘打印助手PrintAssistant项目规划01.md》** 是项目的唯一权威技术文档
- 所有技术决策必须基于规划书进行
- 任何架构变更都必须首先更新规划书
- 代码实现必须与规划书设计保持一致

### 2. 架构一致性原则
- 严格遵循规划书中定义的8个核心部分架构
- 使用指定的技术栈和设计模式
- 所有服务注册必须符合规划书表1.1的要求
- 配置项必须与规划书表1.2保持一致

### 3. 可测试性原则
- 所有外部依赖必须通过接口抽象化
- 使用依赖注入而非静态依赖
- 每个类和方法都必须可进行单元测试
- 测试覆盖率必须达到规划书要求

## 🏗️ 开发规则

### 1. 代码结构规则

#### 目录结构规则
```
✅ 必须遵循的目录结构：
src/PrintAssistant/
├── Assets/           # 资源文件
├── Configuration/    # 配置相关
├── Core/            # 核心业务对象
├── Services/        # 服务实现
│   ├── Abstractions/  # 接口定义
│   ├── Converters/    # 转换器实现
│   └── UI/           # UI服务
└── UI/              # 用户界面

tests/PrintAssistant.Tests/
└── Services/        # 测试文件
```

#### 文件命名规则
- **接口文件**：以 `I` 开头，如 `IFileMonitor.cs`
- **实现文件**：去掉 `I` 前缀，如 `FileMonitorService.cs`
- **配置类**：以 `Settings` 结尾，如 `MonitorSettings.cs`
- **枚举类**：以描述性名称命名，如 `JobStatus.cs`

### 2. 编码规则

#### 依赖注入规则
```csharp
// ✅ 正确：构造函数注入
public class FileMonitorService : IFileMonitor
{
    private readonly IFileSystem _fileSystem;
    private readonly ILogger<FileMonitorService> _logger;
    
    public FileMonitorService(IFileSystem fileSystem, ILogger<FileMonitorService> logger)
    {
        _fileSystem = fileSystem ?? throw new ArgumentNullException(nameof(fileSystem));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }
}

// ❌ 错误：静态依赖
public class FileMonitorService : IFileMonitor
{
    public void StartMonitoring(string path)
    {
        var watcher = new FileSystemWatcher(path); // 直接使用静态类
    }
}
```

#### 异步编程规则
```csharp
// ✅ 正确：使用async/await
public async Task<Stream> ConvertToPdfAsync(string sourceFilePath)
{
    using var fileStream = _fileSystem.File.OpenRead(sourceFilePath);
    // 异步操作...
    return await ProcessFileAsync(fileStream);
}

// ❌ 错误：阻塞调用
public Stream ConvertToPdf(string sourceFilePath)
{
    var fileStream = _fileSystem.File.OpenRead(sourceFilePath);
    return ProcessFile(fileStream); // 同步阻塞
}
```

#### 资源管理规则
```csharp
// ✅ 正确：使用using语句
public async Task<Stream> ConvertToPdfAsync(string sourceFilePath)
{
    using var fileStream = _fileSystem.File.OpenRead(sourceFilePath);
    using var wordDocument = new WordDocument(fileStream, FormatType.Automatic);
    using var renderer = new DocIORenderer();
    
    var pdfDocument = renderer.ConvertToPDF(wordDocument);
    var pdfStream = new MemoryStream();
    pdfDocument.Save(pdfStream);
    return pdfStream;
}

// ❌ 错误：未释放资源
public async Task<Stream> ConvertToPdfAsync(string sourceFilePath)
{
    var fileStream = _fileSystem.File.OpenRead(sourceFilePath);
    var wordDocument = new WordDocument(fileStream, FormatType.Automatic);
    // 资源未释放，可能导致内存泄漏
    return new MemoryStream();
}
```

### 3. 文档规则

#### XML注释规则
```csharp
/// <summary>
/// 文件监控服务，负责监控指定文件夹的文件变化并生成打印作业
/// </summary>
/// <remarks>
/// 实现防抖机制，将连续的文件添加操作聚合为单个打印作业。
/// 使用FileSystemWatcher监控文件系统事件，并通过事件防抖避免任务碎片化。
/// </remarks>
public class FileMonitorService : IFileMonitor
{
    /// <summary>
    /// 开始监控指定路径的文件夹
    /// </summary>
    /// <param name="path">要监控的文件夹路径</param>
    /// <exception cref="ArgumentException">当路径为空或不存在时抛出</exception>
    /// <returns>表示异步操作的任务</returns>
    public async Task StartMonitoringAsync(string path)
    {
        // 实现...
    }
}
```

#### 编码格式规则
- **文件编码**：必须使用 UTF-8 BOM 编码
- **换行符**：使用 Windows 风格（CRLF）
- **缩进**：使用 4 个空格
- **大括号**：使用 Allman 风格

#### 文件I/O编码规则
在进行文件 I/O 操作（如 StreamReader/StreamWriter）时，不要依赖系统默认编码，而应显式使用 Encoding.UTF8 来读取或写入文件内容。

```csharp
// ✅ 正确：显式指定UTF-8编码
using var reader = new StreamReader(filePath, Encoding.UTF8);
using var writer = new StreamWriter(filePath, false, Encoding.UTF8);

// 或者使用File类的静态方法
var content = await File.ReadAllTextAsync(filePath, Encoding.UTF8);
await File.WriteAllTextAsync(filePath, content, Encoding.UTF8);

// ❌ 错误：依赖系统默认编码
using var reader = new StreamReader(filePath); // 可能使用系统默认编码
using var writer = new StreamWriter(filePath); // 可能使用系统默认编码
```

**重要说明**：
- 所有文本文件的读写操作都必须显式指定 UTF-8 编码
- 这确保了在不同系统环境下文件编码的一致性
- 避免了因系统默认编码差异导致的乱码问题
- 符合项目统一使用 UTF-8 BOM 编码的要求

#### 代码构建原则
- 在编写或更新代码之前，必须优先查阅 `docs/PrintAssistant 完整项目代码.md` 中的对应参考实现。
- 仅当参考文档中不存在相关内容时，才可自行设计与实现，并需确保与项目规划保持一致。
- 如需自行构建实现，需在提交说明中明确标注并记录原因，便于后续审查与维护。

## 🧪 测试规则

### 1. 单元测试规则

#### 测试文件结构
```csharp
/// <summary>
/// FileMonitorService的单元测试
/// </summary>
public class FileMonitorServiceTests
{
    private readonly Mock<IFileSystem> _mockFileSystem;
    private readonly Mock<IPrintQueue> _mockPrintQueue;
    private readonly Mock<ILogger<FileMonitorService>> _mockLogger;
    private readonly FileMonitorService _service;
    
    public FileMonitorServiceTests()
    {
        // Arrange: 设置测试环境
        _mockFileSystem = new Mock<IFileSystem>();
        _mockPrintQueue = new Mock<IPrintQueue>();
        _mockLogger = new Mock<ILogger<FileMonitorService>>();
        
        _service = new FileMonitorService(
            _mockFileSystem.Object,
            _mockPrintQueue.Object,
            _mockLogger.Object);
    }
    
    [Fact]
    public async Task StartMonitoring_WhenFilesAdded_ShouldAggregateIntoJob()
    {
        // Arrange
        var testPath = @"C:\test";
        
        // Act
        await _service.StartMonitoringAsync(testPath);
        
        // Assert
        _mockPrintQueue.Verify(
            x => x.EnqueueJobAsync(It.IsAny<PrintJob>()), 
            Times.Once);
    }
}
```

#### 测试命名规则
- **格式**：`MethodName_Scenario_ExpectedResult`
- **示例**：
  - `ConvertToPdfAsync_WhenValidWordFile_ShouldReturnPdfStream`
  - `ConvertToPdfAsync_WhenFileNotFound_ShouldThrowFileNotFoundException`

### 2. 测试覆盖率规则
- **最低覆盖率**：80%
- **关键模块覆盖率**：95%（如文件监控、转换器、打印服务）
- **新代码覆盖率**：100%

## 🔧 配置规则

### 1. 配置文件规则

#### appsettings.json 结构
```json
{
  "Serilog": {
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "System": "Warning"
      }
    },
    "WriteTo": [
      {
        "Name": "File",
        "Args": {
          "path": "C:\\Users\\用户名\\AppData\\Local\\PrintAssistant\\Logs\\log-.txt",
          "rollingInterval": "Day",
          "retainedFileTimeLimit": "7.00:00:00"
        }
      }
    ]
  },
  "ApplicationSettings": {
    "Monitoring": {
      "Path": "C:\\Users\\DefaultUser\\Desktop\\PrintJobs",
      "DebounceIntervalMilliseconds": 2500
    },
    "Printing": {
      "ExcludedPrinters": []
    },
    "Archiving": {
      "SubdirectoryFormat": "Processed_{0:yyyyMMdd_HHmmss}"
    }
  }
}
```

### 2. 服务注册规则

#### 必须注册的服务（按规划书表1.1）
```csharp
// 核心服务
services.AddSingleton<IPrintQueue, PrintQueueService>();
services.AddSingleton<IFileMonitor, FileMonitorService>();
services.AddSingleton<IFileConverterFactory, FileConverterFactory>();
services.AddSingleton<IPrintService, PrintService>();
services.AddSingleton<IFileArchiver, FileArchiver>();
services.AddSingleton<ITrayIconService, TrayIconService>();

// 转换器服务
services.AddTransient<IFileConverter, WordToPdfConverter>();
services.AddTransient<IFileConverter, ExcelToPdfConverter>();
services.AddTransient<IFileConverter, ImageToPdfConverter>();

// UI服务
services.AddTransient<SettingsForm>();
services.AddTransient<PrinterSelectionForm>();

// 托管服务
services.AddHostedService<PrintProcessorService>();
```

## 🚨 错误处理规则

### 1. 异常处理规则

#### 全局异常处理
```csharp
// 在Program.cs中设置全局异常处理
Application.ThreadException += (sender, e) =>
{
    _logger.LogFatal(e.Exception, "未处理的线程异常");
    // 记录日志并安全关闭应用
};

AppDomain.CurrentDomain.UnhandledException += (sender, e) =>
{
    _logger.LogFatal(e.ExceptionObject as Exception, "未处理的应用程序异常");
    // 记录日志并安全关闭应用
};
```

#### 特定异常处理
```csharp
// ✅ 正确：具体的异常处理
public async Task<Stream> ConvertToPdfAsync(string sourceFilePath)
{
    try
    {
        if (!_fileSystem.File.Exists(sourceFilePath))
        {
            throw new FileNotFoundException($"源文件不存在：{sourceFilePath}");
        }
        
        // 转换逻辑...
    }
    catch (SyncfusionException ex)
    {
        _logger.LogError(ex, "Syncfusion转换失败：{FilePath}", sourceFilePath);
        throw new DocumentConversionException($"文档转换失败：{ex.Message}", ex);
    }
    catch (UnauthorizedAccessException ex)
    {
        _logger.LogError(ex, "文件访问权限不足：{FilePath}", sourceFilePath);
        throw;
    }
}

// ❌ 错误：捕获所有异常
public async Task<Stream> ConvertToPdfAsync(string sourceFilePath)
{
    try
    {
        // 转换逻辑...
    }
    catch (Exception ex) // 过于宽泛
    {
        _logger.LogError(ex, "转换失败");
        throw;
    }
}
```

### 2. 日志记录规则

#### 结构化日志
```csharp
// ✅ 正确：使用结构化日志
_logger.LogInformation("开始监控文件夹 {Path}，防抖间隔 {Interval}ms", 
    _settings.Path, _settings.DebounceIntervalMilliseconds);

_logger.LogWarning("文件转换失败 {FilePath}，错误：{Error}", 
    filePath, ex.Message);

// ❌ 错误：使用字符串拼接
_logger.LogInformation("开始监控文件夹 " + _settings.Path);
```

## 🔄 版本控制规则

### 1. Git提交规则

#### 提交信息格式
```
<类型>: <简短描述>

<详细描述>

<相关Issue或PR>
```

#### 提交类型
- `feat`: 新功能
- `fix`: 修复bug
- `docs`: 文档更新
- `style`: 代码格式调整
- `refactor`: 代码重构
- `test`: 测试相关
- `chore`: 构建过程或辅助工具的变动

#### 提交示例
```
feat: 实现文件监控服务

- 添加FileMonitorService类
- 实现事件防抖机制
- 支持文件聚合为打印作业
- 添加相关单元测试

Closes #123
```

### 2. 分支管理规则

#### 分支命名
- `main`: 主分支，生产就绪代码
- `develop`: 开发分支，集成最新功能
- `feature/*`: 功能分支，如 `feature/file-monitor`
- `bugfix/*`: 修复分支，如 `bugfix/memory-leak`
- `hotfix/*`: 热修复分支，如 `hotfix/critical-bug`

#### 合并规则
- 所有功能分支必须合并到 `develop`
- 只有通过测试的代码才能合并到 `main`
- 使用 Pull Request 进行代码审查
- 必须通过所有自动化测试

## 📊 质量检查规则

### 1. 代码审查检查点

#### 架构一致性检查
- [ ] 是否遵循了规划书中的设计模式？
- [ ] 是否使用了正确的依赖注入方式？
- [ ] 是否实现了规划书中定义的接口？
- [ ] 服务注册是否符合规划书表1.1？

#### 可测试性检查
- [ ] 所有外部依赖是否都已抽象化？
- [ ] 是否避免了静态依赖？
- [ ] 是否可以通过依赖注入进行测试？
- [ ] 是否有对应的单元测试？

#### 代码质量检查
- [ ] 是否有完整的XML文档注释？
- [ ] 是否遵循了命名规范？
- [ ] 是否正确处理了异常？
- [ ] 是否正确管理了资源？
- [ ] 是否使用了异步编程？

### 2. 自动化检查

#### 构建检查
- [ ] 代码编译通过
- [ ] 所有单元测试通过
- [ ] 代码覆盖率达标
- [ ] 静态代码分析通过

#### 部署检查
- [ ] 配置文件正确
- [ ] 依赖项完整
- [ ] 日志配置正确
- [ ] 权限设置正确

## 🚫 禁止规则

### 1. 严格禁止的行为

#### 架构违规
- ❌ 直接使用 `System.IO` 静态方法
- ❌ 在业务逻辑中硬编码配置值
- ❌ 使用同步阻塞调用
- ❌ 忽略资源释放

#### 代码质量违规
- ❌ 提交没有注释的公共方法
- ❌ 使用 `catch (Exception)` 捕获所有异常
- ❌ 忽略编译警告
- ❌ 提交未测试的代码

#### 版本控制违规
- ❌ 直接向 `main` 分支提交代码
- ❌ 提交包含敏感信息的代码
- ❌ 提交临时文件或调试代码
- ❌ 使用无意义的提交信息

### 2. 需要特别批准的行为

#### 架构变更
- 修改核心架构设计
- 引入新的第三方库
- 更改服务注册方式
- 修改配置结构

#### 性能优化
- 修改内存管理策略
- 更改异步处理方式
- 优化文件I/O操作
- 调整日志记录级别

## ✅ 规则执行

### 1. 规则检查流程

#### 开发前检查
- [ ] 已阅读项目规划书相关章节
- [ ] 理解了架构设计要求
- [ ] 确认了技术实现方案
- [ ] 制定了测试策略

#### 开发中检查
- [ ] 遵循编码标准
- [ ] 实现接口定义
- [ ] 编写单元测试
- [ ] 添加文档注释

#### 开发后检查
- [ ] 代码审查通过
- [ ] 测试验证通过
- [ ] 文档更新完成
- [ ] 版本控制正确

### 2. 违规处理

#### 轻微违规
- 代码审查中发现问题
- 要求修改后重新提交
- 记录违规情况

#### 严重违规
- 违反架构设计原则
- 影响系统稳定性
- 需要架构师审查
- 可能需要重构

## 🔄 迭代开发规则

### 1. 迭代开发原则

#### 迭代式里程碑交付
项目采用迭代式开发模式，每个迭代都必须交付可演示的产物，确保项目进度可控和风险最小化。

#### 迭代规划依据
迭代规划基于项目规划书的8个核心部分，确保每个迭代都有明确的技术目标和业务价值。

### 2. 迭代划分规则

#### 迭代0：架构与骨架
**目标**：建立项目基础架构和核心框架

**交付物**：
- [ ] 完整的Solution结构
- [ ] .NET Generic Host + DI框架配置
- [ ] 核心接口定义：IFileMonitor、IPrintQueue、ITrayIconService
- [ ] 接口的最小实现（Mock实现）
- [ ] 单元测试框架搭建
- [ ] CI/CD流水线（静态分析）

**技术重点**：
- 依赖注入容器配置
- 服务注册和生命周期管理
- 基础配置管理
- 日志框架集成

**验收标准**：
- 项目能够成功编译和运行
- 所有核心接口都有对应的实现
- 单元测试框架能够执行测试
- CI/CD流水线能够自动构建

#### 迭代1：文件监控 + 队列 + 简单打印
**目标**：实现核心业务流程的基础功能

**交付物**：
- [ ] 文件监控服务完整实现
- [ ] 事件防抖机制
- [ ] 任务入队和队列管理
- [ ] PrintProcessorService基本循环
- [ ] Mock IPrintService打印模拟
- [ ] 托盘图标UI
- [ ] SettingsForm配置界面

**技术重点**：
- FileSystemWatcher集成
- 防抖算法实现
- BufferBlock<T>队列操作
- 跨线程UI更新
- 配置界面数据绑定

**验收标准**：
- 能够监控指定文件夹的文件变化
- 连续文件操作能够正确聚合为单个任务
- 任务能够正确入队和处理
- 托盘图标能够显示状态信息
- 配置界面能够保存和加载设置

**演示场景**：
- 向监控文件夹添加文件
- 观察任务入队过程
- 查看托盘图标状态变化
- 通过配置界面修改设置

#### 迭代2：转换与合并
**目标**：实现文档转换和PDF合并功能

**交付物**：
- [ ] Syncfusion转换器实现
- [ ] Word/Excel/Image到PDF转换
- [ ] 边转换边合并策略
- [ ] PageCount正确计算
- [ ] 文件归档功能
- [ ] 内存/负载基线测试

**技术重点**：
- Syncfusion.DocIO集成
- 内存流管理优化
- PDF合并算法
- 页面计数逻辑
- 文件归档机制

**验收标准**：
- 支持所有规划书要求的文件格式转换
- 转换后的PDF质量符合要求
- 多文件合并功能正常
- 页面计数准确
- 内存使用在合理范围内
- 归档功能正确执行

**演示场景**：
- 转换各种格式的文档
- 合并多个文件为单个PDF
- 验证页面计数准确性
- 检查归档文件结构

#### 迭代3：健壮性与发布
**目标**：完善系统稳定性和准备发布

**交付物**：
- [ ] 完整的打印后端实现（IronPDF或Spooler）
- [ ] 错误处理和重试策略
- [ ] 日志保留策略
- [ ] 权限和安装测试
- [ ] 完整的单元/集成测试
- [ ] 打包和安装程序
- [ ] appsettings可覆盖配置

**技术重点**：
- 真实打印功能实现
- 异常处理和恢复机制
- 日志轮转和清理
- 安装程序制作
- 权限管理
- 性能优化

**验收标准**：
- 能够真实打印PDF文档
- 错误处理机制完善
- 日志管理符合要求
- 安装程序能够正确部署
- 所有测试用例通过
- 性能指标达标

**演示场景**：
- 完整的工作流程演示
- 错误场景处理演示
- 安装和卸载演示
- 性能测试演示

### 3. 迭代开发规则

#### 迭代开始规则
- [ ] 迭代目标必须明确定义
- [ ] 技术方案必须经过评审
- [ ] 验收标准必须清晰可测
- [ ] 演示场景必须准备就绪

#### 迭代进行规则
- [ ] 每日进度必须可追踪
- [ ] 技术决策必须记录
- [ ] 代码质量必须持续保证
- [ ] 测试覆盖率必须达标

#### 迭代结束规则
- [ ] 所有交付物必须完成
- [ ] 验收标准必须全部通过
- [ ] 演示场景必须成功执行
- [ ] 代码审查必须通过
- [ ] 文档必须更新完成

### 4. 迭代质量保证

#### 代码质量要求
- **迭代0**：基础架构代码质量100%
- **迭代1**：核心功能代码质量95%
- **迭代2**：转换功能代码质量95%
- **迭代3**：发布版本代码质量100%

#### 测试覆盖率要求
- **迭代0**：接口测试覆盖率100%
- **迭代1**：核心功能测试覆盖率90%
- **迭代2**：转换功能测试覆盖率95%
- **迭代3**：整体测试覆盖率95%

#### 性能要求
- **迭代1**：基础功能响应时间<1秒
- **迭代2**：转换性能满足业务需求
- **迭代3**：整体性能达到生产标准

### 5. 迭代风险管理

#### 技术风险控制
- 每个迭代开始前进行技术风险评估
- 关键技术点必须有备选方案
- 复杂功能必须进行原型验证

#### 进度风险控制
- 每周进行进度评估
- 发现延期风险及时调整计划
- 必要时调整迭代范围

#### 质量风险控制
- 每个迭代结束前进行质量评估
- 发现质量问题必须解决后才能进入下一迭代
- 建立质量门禁机制

### 6. 迭代文档管理

#### 迭代计划文档
- 每个迭代开始前创建详细的迭代计划
- 包含技术方案、验收标准、演示场景
- 计划变更必须经过评审

#### 迭代总结文档
- 每个迭代结束后创建迭代总结
- 包含完成情况、问题总结、经验教训
- 为下一迭代提供改进建议

#### 技术决策记录
- 记录每个迭代中的重大技术决策
- 包含决策原因、备选方案、影响评估
- 为后续维护提供参考

## 📚 相关文档

- [项目规划书](../托盘打印助手PrintAssistant项目规划01.md) - 总纲性文件
- [项目迭代规划](../项目迭代规划01.txt) - 迭代开发规划
- [开发实施检查清单](../implementation/开发实施检查清单.md) - 实施指导
- [编码标准与规范](./编码标准与规范.md) - 详细编码规范
- [项目总纲版本控制](../architecture/项目总纲版本控制.md) - 版本管理

---

**重要提醒**：这些规则是确保项目质量和成功的关键，请所有开发成员严格遵守。如有疑问，请参考项目规划书或联系项目架构师。

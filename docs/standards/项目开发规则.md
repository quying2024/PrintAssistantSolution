# PrintAssistant 项目开发规则

## 📋 项目规则概述

本文档定义了PrintAssistant项目的开发规则、约束和最佳实践。所有参与项目开发的成员都必须严格遵守这些规则。

## 🎯 核心规则原则

### 1. 规划书权威性原则
- **《托盘打印助手PrintAssistant项目规划01.md》** 是项目的唯一权威技术文档
- 所有技术决策必须基于规划书进行
- 任何架构变更都必须首先更新规划书
- 代码实现必须与规划书设计保持一致

### 2. 架构一致性原则
- 严格遵循规划书中定义的8个核心部分架构
- 使用指定的技术栈和设计模式
- 所有服务注册必须符合规划书表1.1的要求
- 配置项必须与规划书表1.2保持一致

### 3. 可测试性原则
- 所有外部依赖必须通过接口抽象化
- 使用依赖注入而非静态依赖
- 每个类和方法都必须可进行单元测试
- 测试覆盖率必须达到规划书要求

## 🏗️ 开发规则

### 1. 代码结构规则

#### 目录结构规则
```
✅ 必须遵循的目录结构：
src/PrintAssistant/
├── Assets/           # 资源文件
├── Configuration/    # 配置相关
├── Core/            # 核心业务对象
├── Services/        # 服务实现
│   ├── Abstractions/  # 接口定义
│   ├── Converters/    # 转换器实现
│   └── UI/           # UI服务
└── UI/              # 用户界面

tests/PrintAssistant.Tests/
└── Services/        # 测试文件
```

#### 文件命名规则
- **接口文件**：以 `I` 开头，如 `IFileMonitor.cs`
- **实现文件**：去掉 `I` 前缀，如 `FileMonitorService.cs`
- **配置类**：以 `Settings` 结尾，如 `MonitorSettings.cs`
- **枚举类**：以描述性名称命名，如 `JobStatus.cs`

### 2. 编码规则

#### 依赖注入规则
```csharp
// ✅ 正确：构造函数注入
public class FileMonitorService : IFileMonitor
{
    private readonly IFileSystem _fileSystem;
    private readonly ILogger<FileMonitorService> _logger;
    
    public FileMonitorService(IFileSystem fileSystem, ILogger<FileMonitorService> logger)
    {
        _fileSystem = fileSystem ?? throw new ArgumentNullException(nameof(fileSystem));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }
}

// ❌ 错误：静态依赖
public class FileMonitorService : IFileMonitor
{
    public void StartMonitoring(string path)
    {
        var watcher = new FileSystemWatcher(path); // 直接使用静态类
    }
}
```

#### 异步编程规则
```csharp
// ✅ 正确：使用async/await
public async Task<Stream> ConvertToPdfAsync(string sourceFilePath)
{
    using var fileStream = _fileSystem.File.OpenRead(sourceFilePath);
    // 异步操作...
    return await ProcessFileAsync(fileStream);
}

// ❌ 错误：阻塞调用
public Stream ConvertToPdf(string sourceFilePath)
{
    var fileStream = _fileSystem.File.OpenRead(sourceFilePath);
    return ProcessFile(fileStream); // 同步阻塞
}
```

#### 资源管理规则
```csharp
// ✅ 正确：使用using语句
public async Task<Stream> ConvertToPdfAsync(string sourceFilePath)
{
    using var fileStream = _fileSystem.File.OpenRead(sourceFilePath);
    using var wordDocument = new WordDocument(fileStream, FormatType.Automatic);
    using var renderer = new DocIORenderer();
    
    var pdfDocument = renderer.ConvertToPDF(wordDocument);
    var pdfStream = new MemoryStream();
    pdfDocument.Save(pdfStream);
    return pdfStream;
}

// ❌ 错误：未释放资源
public async Task<Stream> ConvertToPdfAsync(string sourceFilePath)
{
    var fileStream = _fileSystem.File.OpenRead(sourceFilePath);
    var wordDocument = new WordDocument(fileStream, FormatType.Automatic);
    // 资源未释放，可能导致内存泄漏
    return new MemoryStream();
}
```

### 3. 文档规则

#### XML注释规则
```csharp
/// <summary>
/// 文件监控服务，负责监控指定文件夹的文件变化并生成打印作业
/// </summary>
/// <remarks>
/// 实现防抖机制，将连续的文件添加操作聚合为单个打印作业。
/// 使用FileSystemWatcher监控文件系统事件，并通过事件防抖避免任务碎片化。
/// </remarks>
public class FileMonitorService : IFileMonitor
{
    /// <summary>
    /// 开始监控指定路径的文件夹
    /// </summary>
    /// <param name="path">要监控的文件夹路径</param>
    /// <exception cref="ArgumentException">当路径为空或不存在时抛出</exception>
    /// <returns>表示异步操作的任务</returns>
    public async Task StartMonitoringAsync(string path)
    {
        // 实现...
    }
}
```

#### 编码格式规则
- **文件编码**：必须使用 UTF-8 BOM 编码
- **换行符**：使用 Windows 风格（CRLF）
- **缩进**：使用 4 个空格
- **大括号**：使用 Allman 风格

## 🧪 测试规则

### 1. 单元测试规则

#### 测试文件结构
```csharp
/// <summary>
/// FileMonitorService的单元测试
/// </summary>
public class FileMonitorServiceTests
{
    private readonly Mock<IFileSystem> _mockFileSystem;
    private readonly Mock<IPrintQueue> _mockPrintQueue;
    private readonly Mock<ILogger<FileMonitorService>> _mockLogger;
    private readonly FileMonitorService _service;
    
    public FileMonitorServiceTests()
    {
        // Arrange: 设置测试环境
        _mockFileSystem = new Mock<IFileSystem>();
        _mockPrintQueue = new Mock<IPrintQueue>();
        _mockLogger = new Mock<ILogger<FileMonitorService>>();
        
        _service = new FileMonitorService(
            _mockFileSystem.Object,
            _mockPrintQueue.Object,
            _mockLogger.Object);
    }
    
    [Fact]
    public async Task StartMonitoring_WhenFilesAdded_ShouldAggregateIntoJob()
    {
        // Arrange
        var testPath = @"C:\test";
        
        // Act
        await _service.StartMonitoringAsync(testPath);
        
        // Assert
        _mockPrintQueue.Verify(
            x => x.EnqueueJobAsync(It.IsAny<PrintJob>()), 
            Times.Once);
    }
}
```

#### 测试命名规则
- **格式**：`MethodName_Scenario_ExpectedResult`
- **示例**：
  - `ConvertToPdfAsync_WhenValidWordFile_ShouldReturnPdfStream`
  - `ConvertToPdfAsync_WhenFileNotFound_ShouldThrowFileNotFoundException`

### 2. 测试覆盖率规则
- **最低覆盖率**：80%
- **关键模块覆盖率**：95%（如文件监控、转换器、打印服务）
- **新代码覆盖率**：100%

## 🔧 配置规则

### 1. 配置文件规则

#### appsettings.json 结构
```json
{
  "Serilog": {
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "System": "Warning"
      }
    },
    "WriteTo": [
      {
        "Name": "File",
        "Args": {
          "path": "C:\\Users\\用户名\\AppData\\Local\\PrintAssistant\\Logs\\log-.txt",
          "rollingInterval": "Day",
          "retainedFileTimeLimit": "7.00:00:00"
        }
      }
    ]
  },
  "ApplicationSettings": {
    "Monitoring": {
      "Path": "C:\\Users\\DefaultUser\\Desktop\\PrintJobs",
      "DebounceIntervalMilliseconds": 2500
    },
    "Printing": {
      "ExcludedPrinters": []
    },
    "Archiving": {
      "SubdirectoryFormat": "Processed_{0:yyyyMMdd_HHmmss}"
    }
  }
}
```

### 2. 服务注册规则

#### 必须注册的服务（按规划书表1.1）
```csharp
// 核心服务
services.AddSingleton<IPrintQueue, PrintQueueService>();
services.AddSingleton<IFileMonitor, FileMonitorService>();
services.AddSingleton<IFileConverterFactory, FileConverterFactory>();
services.AddSingleton<IPrintService, PrintService>();
services.AddSingleton<IFileArchiver, FileArchiver>();
services.AddSingleton<ITrayIconService, TrayIconService>();

// 转换器服务
services.AddTransient<IFileConverter, WordToPdfConverter>();
services.AddTransient<IFileConverter, ExcelToPdfConverter>();
services.AddTransient<IFileConverter, ImageToPdfConverter>();

// UI服务
services.AddTransient<SettingsForm>();
services.AddTransient<PrinterSelectionForm>();

// 托管服务
services.AddHostedService<PrintProcessorService>();
```

## 🚨 错误处理规则

### 1. 异常处理规则

#### 全局异常处理
```csharp
// 在Program.cs中设置全局异常处理
Application.ThreadException += (sender, e) =>
{
    _logger.LogFatal(e.Exception, "未处理的线程异常");
    // 记录日志并安全关闭应用
};

AppDomain.CurrentDomain.UnhandledException += (sender, e) =>
{
    _logger.LogFatal(e.ExceptionObject as Exception, "未处理的应用程序异常");
    // 记录日志并安全关闭应用
};
```

#### 特定异常处理
```csharp
// ✅ 正确：具体的异常处理
public async Task<Stream> ConvertToPdfAsync(string sourceFilePath)
{
    try
    {
        if (!_fileSystem.File.Exists(sourceFilePath))
        {
            throw new FileNotFoundException($"源文件不存在：{sourceFilePath}");
        }
        
        // 转换逻辑...
    }
    catch (SyncfusionException ex)
    {
        _logger.LogError(ex, "Syncfusion转换失败：{FilePath}", sourceFilePath);
        throw new DocumentConversionException($"文档转换失败：{ex.Message}", ex);
    }
    catch (UnauthorizedAccessException ex)
    {
        _logger.LogError(ex, "文件访问权限不足：{FilePath}", sourceFilePath);
        throw;
    }
}

// ❌ 错误：捕获所有异常
public async Task<Stream> ConvertToPdfAsync(string sourceFilePath)
{
    try
    {
        // 转换逻辑...
    }
    catch (Exception ex) // 过于宽泛
    {
        _logger.LogError(ex, "转换失败");
        throw;
    }
}
```

### 2. 日志记录规则

#### 结构化日志
```csharp
// ✅ 正确：使用结构化日志
_logger.LogInformation("开始监控文件夹 {Path}，防抖间隔 {Interval}ms", 
    _settings.Path, _settings.DebounceIntervalMilliseconds);

_logger.LogWarning("文件转换失败 {FilePath}，错误：{Error}", 
    filePath, ex.Message);

// ❌ 错误：使用字符串拼接
_logger.LogInformation("开始监控文件夹 " + _settings.Path);
```

## 🔄 版本控制规则

### 1. Git提交规则

#### 提交信息格式
```
<类型>: <简短描述>

<详细描述>

<相关Issue或PR>
```

#### 提交类型
- `feat`: 新功能
- `fix`: 修复bug
- `docs`: 文档更新
- `style`: 代码格式调整
- `refactor`: 代码重构
- `test`: 测试相关
- `chore`: 构建过程或辅助工具的变动

#### 提交示例
```
feat: 实现文件监控服务

- 添加FileMonitorService类
- 实现事件防抖机制
- 支持文件聚合为打印作业
- 添加相关单元测试

Closes #123
```

### 2. 分支管理规则

#### 分支命名
- `main`: 主分支，生产就绪代码
- `develop`: 开发分支，集成最新功能
- `feature/*`: 功能分支，如 `feature/file-monitor`
- `bugfix/*`: 修复分支，如 `bugfix/memory-leak`
- `hotfix/*`: 热修复分支，如 `hotfix/critical-bug`

#### 合并规则
- 所有功能分支必须合并到 `develop`
- 只有通过测试的代码才能合并到 `main`
- 使用 Pull Request 进行代码审查
- 必须通过所有自动化测试

## 📊 质量检查规则

### 1. 代码审查检查点

#### 架构一致性检查
- [ ] 是否遵循了规划书中的设计模式？
- [ ] 是否使用了正确的依赖注入方式？
- [ ] 是否实现了规划书中定义的接口？
- [ ] 服务注册是否符合规划书表1.1？

#### 可测试性检查
- [ ] 所有外部依赖是否都已抽象化？
- [ ] 是否避免了静态依赖？
- [ ] 是否可以通过依赖注入进行测试？
- [ ] 是否有对应的单元测试？

#### 代码质量检查
- [ ] 是否有完整的XML文档注释？
- [ ] 是否遵循了命名规范？
- [ ] 是否正确处理了异常？
- [ ] 是否正确管理了资源？
- [ ] 是否使用了异步编程？

### 2. 自动化检查

#### 构建检查
- [ ] 代码编译通过
- [ ] 所有单元测试通过
- [ ] 代码覆盖率达标
- [ ] 静态代码分析通过

#### 部署检查
- [ ] 配置文件正确
- [ ] 依赖项完整
- [ ] 日志配置正确
- [ ] 权限设置正确

## 🚫 禁止规则

### 1. 严格禁止的行为

#### 架构违规
- ❌ 直接使用 `System.IO` 静态方法
- ❌ 在业务逻辑中硬编码配置值
- ❌ 使用同步阻塞调用
- ❌ 忽略资源释放

#### 代码质量违规
- ❌ 提交没有注释的公共方法
- ❌ 使用 `catch (Exception)` 捕获所有异常
- ❌ 忽略编译警告
- ❌ 提交未测试的代码

#### 版本控制违规
- ❌ 直接向 `main` 分支提交代码
- ❌ 提交包含敏感信息的代码
- ❌ 提交临时文件或调试代码
- ❌ 使用无意义的提交信息

### 2. 需要特别批准的行为

#### 架构变更
- 修改核心架构设计
- 引入新的第三方库
- 更改服务注册方式
- 修改配置结构

#### 性能优化
- 修改内存管理策略
- 更改异步处理方式
- 优化文件I/O操作
- 调整日志记录级别

## ✅ 规则执行

### 1. 规则检查流程

#### 开发前检查
- [ ] 已阅读项目规划书相关章节
- [ ] 理解了架构设计要求
- [ ] 确认了技术实现方案
- [ ] 制定了测试策略

#### 开发中检查
- [ ] 遵循编码标准
- [ ] 实现接口定义
- [ ] 编写单元测试
- [ ] 添加文档注释

#### 开发后检查
- [ ] 代码审查通过
- [ ] 测试验证通过
- [ ] 文档更新完成
- [ ] 版本控制正确

### 2. 违规处理

#### 轻微违规
- 代码审查中发现问题
- 要求修改后重新提交
- 记录违规情况

#### 严重违规
- 违反架构设计原则
- 影响系统稳定性
- 需要架构师审查
- 可能需要重构

## 📚 相关文档

- [项目规划书](../托盘打印助手PrintAssistant项目规划01.md) - 总纲性文件
- [开发实施检查清单](../implementation/开发实施检查清单.md) - 实施指导
- [编码标准与规范](./编码标准与规范.md) - 详细编码规范
- [项目总纲版本控制](../architecture/项目总纲版本控制.md) - 版本管理

---

**重要提醒**：这些规则是确保项目质量和成功的关键，请所有开发成员严格遵守。如有疑问，请参考项目规划书或联系项目架构师。
